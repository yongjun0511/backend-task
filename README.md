# 📌 기능 구현 CheckList

### 1. data.txt 파싱하기.
- [x] 신용 점수 상승한 사람만 알림을 보낸다.
- [x] 중복 방지 ( 레코드가 두번 나타나는 경우 -> 전처리 과정 필요)
- [x] 중복의 기준을 확인한다 : 이메일 + 전화번호, 전화 번호, 이메일

### 2. 메시지 전송하기
- [x] SMS 알림 : 100/s
- [x] Email 속도 제한 : 없음
- [x] 알림은 Email과 SMS를 둘 다 보내야 한다.
- [x] 알림 채널 추가 가능성을 고려해서 확장성 있게 구현한다.

### 3. 전송 판단 기준
- [x] output에 email과 phone_number.txt에 기록되면 알림이 전송되었다고 가정한다.

### 4.etc (수정하지 말 것)
- 'clients/email_client.go'
- 'clients/sms_client.go'

위의 내용을 로직에 따라서 잘 되는지 한번 더 점검하고 test 코드도 짜보자.


### 5. refactoring 중점 사항 및 컨밴션 적용 checklist
- [x] Concurrent Safe 하게 설계하면서 병렬성을 신경쓰자 -> 기록의 한계로 병렬적 처리는 힘들어 보임. 대신 다른 txt를 만지는 경우는 병렬성을 신경썻다.
- [ ] Error에 대한 스택 트레이스와 스택 관리
- [ ] 앱 초반에 치명적인 경우 main() 만쓰기 때문에 Panic이 아닌 Fatal을 사용 (Must 붙이기)
- [ ] go 루틴에서 error 반환값을 모아서 Mutil error로 관리하기
- [ ] Error Handling 내부 내용 잘 작성하기 
- [ ] Error Logging (defer, 핸들러에서 로그찍지말고 위로 넘기기, 공통 인터셉터)
- [ ] No_Named Return 사용
- [ ] Slice 선언시 미리 용량 정해두기
- [ ] Slice가 비어있는 것은 len으로 확인 (Nil 사용 x)
- [ ] map[string]struct{} 고려 가능 (map[string] bool 말고)
- [ ] map loop은 순서를 보장하지 않는다
- [ ] 문자열 loop시 range사용 -> 안 쓸 것 같긴함
- [ ] Early Return 사용
- [ ] 시간을 다룰 때 Time.duration 사용하기
- [ ] 기본 인자 사용하기 (default 인자)


뱅샐 코딩 스타일
- [ ] 함수 인자 순서 고려 (중요한 것 먼저쓰기)
- [ ] 선언 순서도 컨밴션이다
- [ ] import 순서는 3개로 관리 
- [ ] 단수는 get 복수는 list
- [ ] const 네이밍은 카멜 케이스
- [ ] 최소한의 패키지를 유지하도록 노력할 것

📌 뱅크샐러드 go 2023 컨밴션 참고
https://blog.banksalad.com/tech/go-best-practice-in-banksalad/

---

벨리데이션에서 발생하는 문제는 에러가 맞나? -> 위치 잘못된거 등등.. 사실 걸린는게 없긴해

validation
- 현재 과제에는 데이터상 문제는 없어보인다, 따라서 큰 문제는 없을 듯하다
- 다만 , 어떤 validation이 왔을 떄는 넘어가도 되고 어떤 것은 좀 큰 문제다 ? 예를 들어 남의 전번이 있거나 이런 경우는 ㄱㅊ 그런데 단순 오타다 한 번 안가도 ㄱㅊ? 
- 현재 저런 것을 내가 판단하는 것은 맞지 않아 보임. 따라서, 분기 가능성을 열어주고 error stack을 쌓아보자. <- 나중에 필요한 경우 수정할 수 있도록.



what was being attempted" 중



쓰는건 안되지만 전처리오 읽는 것은 병렬처리를 할까?

근데 지금 set으로 처리할려던 이유가 데이터의 특수성 때문인데... -> 이걸 8000개로 고정해서 배열을 통해 동시성을 잡는다? 근데 그러면 
그 이후에 여전히 set으로 처리한다면... 뭔가 그 로직이...
그리고 또 문제가 지금 나는 Y를 조지지않는다 이걸 parsing 로직에 넣었거든...? 파씽하는 기준로직을 여기에 담았어 또 필터를 만들기는 좀 그래서
그런데 그래서 Y를 반환하는 것 자체가 여기에 있고 preprocessor에는 로직을 안담으려고 했는데 병렬처리를 위해서는 여기 로직이 담길수밖에 없겠더라고.

그리고 또 병렬처리를 해버릴려면 , 결국 어떤 도메인의 그런 것들을 아는지 preprocessor가 알게 되어버리니까 병렬처리 포기하겠음. 
현재는 아예 user_metadata 만지는 것만으로도 그게 처리가 되어서 Preprocess가 저걸의존하게 만들고싶지 않았네.

---
### 평가 기준

- 정확성 : 별도의 test_data로 실행했을 경우 제대로 작동하는가 (예외 사항에 대한 고민이 필요하다)
- 가독성
- 제약 조건 준수
- 명확성 : README.md 명확하게 작성하기 ( 접근 방식, 속도 제한 처리 방법, 중복 처리 방법, 전체적인 구조)
- 구현 방법에 대한 간략 설명 & 이외에 알아두어야 하는 사항